//
//  Copyright (C) 2010  Nick Gasson
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#include "IScenery.hpp"
#include "ILogger.hpp"

#include <list>
#include <vector>
#include <ostream>
#include <iterator>

namespace lsystem {

   enum Token {
      X = 'X',   // Only used for replacement
      F = 'F',   // Draw forward
      L = 'L',   // Turn left N degrees
      R = 'R',   // Turn right N degrees
   };

   typedef list<Token> TokenList;

   struct Rule {
      Rule(Token lhs, const TokenList& rhs)
         : lhs(lhs), rhs(rhs)
      {}

      Rule(Token lhs, const char* tokenStr);

      Token lhs;
      TokenList rhs;
   };

   struct LSystem {
      LSystem(const Rule* rules, int nRules, Token start);

      const Rule* rules;
      int nRules;
      Token start;
      TokenList state;
   };

   void evolve(LSystem& l);      

   ostream& operator<<(ostream& os, const LSystem& l)
   {
      copy(l.state.begin(), l.state.end(),
         ostream_iterator<char>(os));
      return os;
   }
   
}

lsystem::Rule::Rule(Token lhs, const char* tokenStr)
   : lhs(lhs)
{
   while (*tokenStr)
      rhs.push_back((Token)*tokenStr++);
}


lsystem::LSystem::LSystem(const Rule* rules, int nRules, Token start)
   : rules(rules), nRules(nRules), start(start)
{
   state.push_back(start);
}

void lsystem::evolve(LSystem& l)
{
   TokenList::iterator it = l.state.begin();
   do {
      bool replaced = false;
      for (int r = 0; r < l.nRules; r++) {
         if (l.rules[r].lhs == *it) {
            l.state.insert(it, l.rules[r].rhs.begin(),
               l.rules[r].rhs.end());
            replaced = true;
            break;
         }
      }

      if (replaced)
         it = l.state.erase(it);
      else
         ++it;
            
   } while (it != l.state.end());
}

// Trees generated by L-systems
class LTree : public IScenery {
public:
   LTree();

   // IScenery interface
   void render() const;
   void setPosition(float x, float y, float z);
private:
};

LTree::LTree()
{
   using namespace lsystem;
   
   Rule rules[] = {
      Rule(X, "F-[[X]+X]+F[+FX]-X"),
      Rule(F, "FF"),
   };
   LSystem l(rules, 2, X);

   debug() << "Initial: " << l;
   for (int n = 0; n < 5; n++) {
      evolve(l);
      debug() << "n=" << n << ": " << l;
   }
}

void LTree::render() const
{

}

void LTree::setPosition(float x, float y, float z)
{

}

ISceneryPtr makeLTree()
{
   return ISceneryPtr(new LTree);
}


